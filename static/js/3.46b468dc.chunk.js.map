{"version":3,"sources":["../../serial.ts","components/AndroidSerialLoader.tsx"],"names":["AndroidSerialLoader","navigator","serial"],"mappings":"mOAiCA,IAGM,EAAuC,CAC3C,SAAU,OACV,SAAU,EACV,SAAU,EACR,OAAM,OACN,WAAU,IACV,QAAM,EACN,KAAG,EACH,MAAI,EACJ,MAAI,GAEF,EAAsB,CAAC,GAAI,EAAG,EAAG,EAAG,GACpC,EAAsB,CAAC,EAAG,GAC1B,EAAoB,CAAC,OAAQ,OAAQ,OAAQ,MAAO,SAEpD,EACF,CAAC,OAAQ,MAAO,OAAQ,OAAQ,SAC9B,EAAwB,CAAC,EAAG,IAAK,GAG1B,E,WAaT,SAAF,EAAmB,EAAmB,GAA6B,UAC7D,KAAC,eAAc,iBAAO,EAA0B,GAChD,KAAC,kBAED,KAAC,QAAQ,G,sKAWL,KAAK,QAAQ,O,UACgB,OAA/B,KAAK,QAAQ,c,gCACT,KAAK,QAAQ,oBAAoB,G,UAGnC,EAAoB,KAAK,qBAAqB,KAAK,S,sBAEjD,IAAI,MAAM,2C,UAElB,KAAK,mBAAqB,EAEpB,EAAmB,KAAK,oBAAoB,KAAK,S,uBAE/C,IAAI,MAAM,qC,yBAGZ,KAAK,QAAQ,eAAe,EAAiB,iB,yBAC7C,KAAK,QAAQ,eACf,KAAK,mBAAmB,iB,yBACtB,KAAK,a,yBACL,KAAK,QAAQ,mBAAmB,CACpC,YAAe,QACf,UAAa,YACb,QA1EqB,GA2ErB,MAAS,EACT,MAAS,EAAiB,kB,QAE5B,KAAK,GAAK,IAAI,eAAe,CAAC,MAAO,KAAK,UAAU,KAAK,QACzD,KAAK,IAAM,IAAI,eAAe,CAC5B,MAAO,KAAK,MAAM,KAAK,Q,wDAGnB,IAAI,MAAM,4BAA8B,KAAM,Y,kQAU/B,KAAK,QAAQ,kBAAkB,CACpD,YAAe,QACf,UAAa,YACb,QA/FiB,GAgGjB,MAAS,EACT,MAAS,GACR,G,UAEqB,QARlB,E,QAQO,O,yCACJ,KAAK,eAAe,EAAS,KAAM,S,uIAS5B,GAChB,IAAM,EAAU,iBAAO,KAAK,eAAmB,GAG/C,OAFA,KAAK,eAAiB,EACtB,KAAK,kBACE,KAAK,qB,8BAQE,GACd,IAAK,EAAW,eAAe,GAC7B,MAAM,IAAI,UAAU,6BAEtB,KAAK,QAAU,I,wCAQf,IAAK,KAAK,gBAAgB,KAAK,eAAe,UAC5C,MAAM,IAAI,WAAW,qBAAuB,KAAK,eAAe,UAGlE,IAAK,KAAK,gBAAgB,KAAK,eAAe,UAC5C,MAAM,IAAI,WAAW,oBAAsB,KAAK,eAAe,UAGjE,IAAK,KAAK,gBAAgB,KAAK,eAAe,UAC5C,MAAM,IAAI,WAAW,oBAAsB,KAAK,eAAe,UAGjE,IAAK,KAAK,cAAc,KAAK,eAAe,QAC1C,MAAM,IAAI,WAAW,kBAAoB,KAAK,eAAe,U,sCASzC,GACtB,OAAO,EAAW,IAAM,I,sCASF,GAChB,OAAC,EAAoB,SAAS,K,sCASd,GACtB,OAAO,EAAoB,SAAS,K,oCAQhB,GACpB,OAAO,EAAkB,SAAS,K,8DASX,G,uNAOD,G,+EAChB,EAAW,KAAK,qBAAqB,M,uBAEzC,EAAW,MAAM,IAAI,MAAM,8B,0BAI7B,UAAC,kHAIe,EAAK,QAAQ,WAAW,EAAS,eAAgB,IAJhE,OAGW,EAHX,OAKK,EAAW,QAAQ,EAAO,MAL/B,6EAQG,EAAW,MAAM,KAAM,YAR1B,wDAAD,G,gKAqBE,EACA,G,wEACI,EAAW,KAAK,qBAAqB,O,uBAEzC,EAAW,MAAM,IAAI,MAAM,+B,+BAIzB,aAAiB,Y,0CAEX,KAAK,QAAQ,YAAY,EAAS,eAAgB,G,yDAExD,EAAW,MAAM,KAAM,Y,sCAGnB,IAAI,UACN,sF,4JAUN,OAAO,KAAK,QAAQ,mBAChB,CACE,YAAe,QACf,UAAa,YACb,QAnQa,GAoQb,MAAS,EACT,MAAS,GAEX,KAAK,4B,qCASY,GACf,MAAyB,KAAK,eAC9B,EAAO,IAAI,SAAS,GAS1B,OARM,EAAE,SAAW,EAAK,UAAU,GAAG,GACrC,EAAQ,SAAW,EAAK,SAAS,GAAK,EAAsB,OACxD,EAAsB,EAAK,SAAS,IACpC,EACJ,EAAQ,OAAS,EAAK,SAAS,GAAK,EAAoB,OACpD,EAAoB,EAAK,SAAS,IAClC,OACJ,EAAQ,SAAW,EAAK,SAAS,GAC1B,I,+CASP,IAAM,EAAS,IAAI,YAAY,GACzB,EAAO,IAAI,SAAS,GAM1B,OALA,EAAK,UAAU,EAAG,KAAK,eAAe,UAAU,GAChD,EAAK,SACD,EAAG,EAAsB,QAAQ,KAAK,eAAe,WACzD,EAAK,SAAS,EAAG,EAAoB,QAAQ,KAAK,eAAe,SACjE,EAAK,SAAS,EAAG,KAAK,eAAe,UAC9B,I,0CA2CmB,GAC1B,OAAO,KAAK,sBAAsB,EAAQ,K,2CASf,GACrB,OAAC,KAAK,sBAAsB,EAAQ,M,4CAUd,EAAmB,GAC/C,IAAI,EAQJ,OAPA,EAAO,cAAe,WAAW,SAAQ,SAAC,GACxC,EAAgB,WAAW,SAAQ,SAAC,GAC9B,EAAU,iBAAmB,IAC/B,EAAqB,SAIpB,I,2CAWoB,GAE3B,IAAI,EAQJ,OAPA,KAAK,mBAAmB,WAAW,SAAQ,SAAC,GAC1C,EAAU,UAAU,SAAQ,SAAC,GACvB,EAAS,WAAa,IACxB,EAAkB,SAIjB,K,sCApFoB,GACrB,OAAO,0BAA0B,OACrC,OAAO,EAGT,IAAI,GAAuB,EACvB,GAAuB,EAkB3B,OAhBA,EAAO,eAAe,SAAQ,SAAC,GACzB,EAAO,sBAAsB,OAC/B,EAAO,WAAW,SAAQ,SAAC,GACrB,EAAc,sBAAsB,OACtC,EAAc,WAAW,SAAQ,SAAC,GACC,KAA7B,EAAU,iBACZ,GAAuB,GAEQ,IAA7B,EAAU,iBACZ,GAAuB,YAO5B,GAAwB,M,KAxTnC,e,IAyXM,E,+LAGI,EAAU,CACd,CAAC,UAAW,K,SAEO,UAAU,IAAI,cAAc,CAAC,QAAW,I,cAAvD,E,OACA,EAAO,IAAI,EAAW,G,kBACrB,G,sPAKe,UAAU,IAAI,a,cAA9B,E,OACA,EAA8B,GACpC,EAAQ,SAAQ,SAAC,GACX,EAAW,eAAe,IAC5B,EAAc,KAAK,IAAI,EAAW,O,kBAG/B,G,wGAKE,SAAS,IAAI,G,iCC1c1B,oCAQeA,UALf,WAEE,OADEC,UAAkBC,OAASA,SACtB","file":"static/js/3.46b468dc.chunk.js","sourcesContent":["/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in\n * compliance with the License. You may obtain a copy of\n * the License at\n *\n *    https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in\n * writing, software distributed under the License is\n * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES\n * OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing\n * permissions and limitations under the License.\n */\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst kSetControlLineState = 0x22;\nconst kGetLineCoding = 0x21;\nconst kSetLineCoding = 0x20;\nconst kDefaultSerialOptions = {\n    baudrate: 115200,\n    databits: 8,\n    stopbits: 1,\n    parity: 'none',\n    buffersize: 255,\n    rtscts: false,\n    xon: false,\n    xoff: false,\n    xany: false,\n};\nconst kAcceptableDataBits = [16, 8, 7, 6, 5];\nconst kAcceptableStopBits = [1, 2];\nconst kAcceptableParity = ['none', 'even', 'mark', 'odd', 'space'];\nconst kParityIndexMapping = ['none', 'odd', 'even', 'mark', 'space'];\nconst kStopbitsIndexMapping = [1, 1.5, 2];\n/** a class used to control serial devices over WebUSB */\nclass SerialPort {\n    /**\n     * constructor taking a WebUSB device that creates a SerialPort instance.\n     * @param {object} device A device acquired from the WebUSB API\n     * @param {object} serialOptions Optional object containing serial options\n     */\n    constructor(device, serialOptions) {\n        this.serialOptions_ = Object.assign({}, kDefaultSerialOptions, serialOptions);\n        this.validateOptions();\n        this.setPort(device);\n    }\n    /**\n     * a function that opens the device and claims all interfaces needed to\n     * control and communicate to and from the serial device\n     * @return {Promise} A promise that will resolve when device is ready for\n     * communication\n     */\n    async open() {\n        try {\n            await this.device_.open();\n            if (this.device_.configuration === null) {\n                await this.device_.selectConfiguration(1);\n            }\n            const transferInterface = this.getTransferInterface(this.device_);\n            if (!transferInterface) {\n                throw new Error('Unable to find data transfer interface.');\n            }\n            this.transferInterface_ = transferInterface;\n            const controlInterface = this.getControlInterface(this.device_);\n            if (!controlInterface) {\n                throw new Error('Unable to find control interface.');\n            }\n            await this.device_.claimInterface(controlInterface.interfaceNumber);\n            await this.device_.claimInterface(this.transferInterface_.interfaceNumber);\n            await this.setOptions();\n            await this.device_.controlTransferOut({\n                'requestType': 'class',\n                'recipient': 'interface',\n                'request': kSetControlLineState,\n                'value': 0x01,\n                'index': controlInterface.interfaceNumber,\n            });\n            this.in = new ReadableStream({ start: this.readStart.bind(this) });\n            this.out = new WritableStream({\n                write: this.write.bind(this),\n            });\n        }\n        catch (error) {\n            throw new Error('Error setting up device: ' + error.toString());\n        }\n    }\n    /**\n     * A function used the get the options directoly from the device\n     * @return {Promise} A promise that will resolve with an object containing\n     * the device serial options\n     */\n    async getInfo() {\n        const response = await this.device_.controlTransferIn({\n            'requestType': 'class',\n            'recipient': 'interface',\n            'request': kGetLineCoding,\n            'value': 0x00,\n            'index': 0x00,\n        }, 7);\n        if (response.status === 'ok') {\n            return this.readLineCoding(response.data.buffer);\n        }\n    }\n    /**\n     * A function used to change the serial settings of the device\n     * @param {object} options the object which carries serial settings data\n     * @return {Promise} A promise that will resolve when the options are set\n     */\n    setOptions(options) {\n        const newOptions = Object.assign({}, this.serialOptions_, options);\n        this.serialOptions_ = newOptions;\n        this.validateOptions();\n        return this.setSerialOptions();\n    }\n    /**\n     * Set the device inside the class and figure out which interface is the\n     * proper one for transfer and control\n     * @param {object} device A device acquired from the WebUSB API\n     */\n    setPort(device) {\n        if (!SerialPort.isSerialDevice(device)) {\n            throw new TypeError('This is not a serial port');\n        }\n        this.device_ = device;\n    }\n    /**\n     * Checks the serial options for validity and throws an error if it is\n     * not valid\n     */\n    validateOptions() {\n        if (!this.isValidBaudRate(this.serialOptions_.baudrate)) {\n            throw new RangeError('invalid Baud Rate ' + this.serialOptions_.baudrate);\n        }\n        if (!this.isValidDataBits(this.serialOptions_.databits)) {\n            throw new RangeError('invalid databits ' + this.serialOptions_.databits);\n        }\n        if (!this.isValidStopBits(this.serialOptions_.stopbits)) {\n            throw new RangeError('invalid stopbits ' + this.serialOptions_.stopbits);\n        }\n        if (!this.isValidParity(this.serialOptions_.parity)) {\n            throw new RangeError('invalid parity ' + this.serialOptions_.parity);\n        }\n    }\n    /**\n     * Checks the baud rate for validity\n     * @param {number} baudrate the baud rate to check\n     * @return {boolean} A boolean that reflects whether the baud rate is valid\n     */\n    isValidBaudRate(baudrate) {\n        return baudrate % 1 === 0;\n    }\n    /**\n     * Checks the data bits for validity\n     * @param {number} databits the data bits to check\n     * @return {boolean} A boolean that reflects whether the data bits setting is\n     * valid\n     */\n    isValidDataBits(databits) {\n        return kAcceptableDataBits.includes(databits);\n    }\n    /**\n     * Checks the stop bits for validity\n     * @param {number} stopbits the stop bits to check\n     * @return {boolean} A boolean that reflects whether the stop bits setting is\n     * valid\n     */\n    isValidStopBits(stopbits) {\n        return kAcceptableStopBits.includes(stopbits);\n    }\n    /**\n     * Checks the parity for validity\n     * @param {string} parity the parity to check\n     * @return {boolean} A boolean that reflects whether the parity is valid\n     */\n    isValidParity(parity) {\n        return kAcceptableParity.includes(parity);\n    }\n    /**\n     * The function called by the writable stream upon creation\n     * @param {WritableStreamDefaultController} controller The stream controller\n     * @return {Promise} A Promise that is to be resolved whe this instance is\n     * ready to use the writablestream\n     */\n    async writeStart(controller) {\n    }\n    /**\n     * The function called by the readable stream upon creation\n     * @param {number} controller The stream controller\n     */\n    async readStart(controller) {\n        const endpoint = this.getDirectionEndpoint('in');\n        if (!endpoint) {\n            controller.error(new Error('No IN endpoint available.'));\n            return;\n        }\n        (async () => {\n            try {\n                for (;;) {\n                    const result = await this.device_.transferIn(endpoint.endpointNumber, 64);\n                    controller.enqueue(result.data);\n                }\n            }\n            catch (error) {\n                controller.error(error.toString());\n            }\n        })();\n    }\n    /**\n     * Sends data along the \"out\" endpoint of this\n     * @param {Uint8Array} chunk the data to be sent out\n     * @param {Object} controller The Object for the\n     * WritableStreamDefaultController used by the WritablSstream API\n     * @return {Promise} a promise that will resolve when the data is sent\n     */\n    async write(chunk, controller) {\n        const endpoint = this.getDirectionEndpoint('out');\n        if (!endpoint) {\n            controller.error(new Error('No OUT endpoint available.'));\n            return;\n        }\n        if (chunk instanceof Uint8Array) {\n            try {\n                await this.device_.transferOut(endpoint.endpointNumber, chunk);\n            }\n            catch (error) {\n                controller.error(error.toString());\n            }\n        }\n        else {\n            throw new TypeError('Can only send Uint8Array please use transform stream to convert ' +\n                'data to Uint8Array');\n        }\n    }\n    /**\n     * sends the options alog the control interface to set them on the device\n     * @return {Promise} a promise that will resolve when the options are set\n     */\n    setSerialOptions() {\n        return this.device_.controlTransferOut({\n            'requestType': 'class',\n            'recipient': 'interface',\n            'request': kSetLineCoding,\n            'value': 0x00,\n            'index': 0x00,\n        }, this.getLineCodingStructure());\n    }\n    /**\n     * Takes in an Array Buffer that contains Line Coding according to the USB\n     * CDC spec\n     * @param {ArrayBuffer} buffer The data structured accoding to the spec\n     * @return {object} The options\n     */\n    readLineCoding(buffer) {\n        const options = this.serialOptions_;\n        const view = new DataView(buffer);\n        options.baudrate = view.getUint32(0, true);\n        options.stopbits = view.getUint8(4) < kStopbitsIndexMapping.length ?\n            kStopbitsIndexMapping[view.getUint8(4)] :\n            1;\n        options.parity = view.getUint8(5) < kParityIndexMapping.length ?\n            kParityIndexMapping[view.getUint8(5)] :\n            'none';\n        options.databits = view.getUint8(6);\n        return options;\n    }\n    /**\n     * Turns the serialOptions into an array buffer structured into accordance to\n     * the USB CDC specification\n     * @return {object} The array buffer with the Line Coding structure\n     */\n    getLineCodingStructure() {\n        const buffer = new ArrayBuffer(7);\n        const view = new DataView(buffer);\n        view.setUint32(0, this.serialOptions_.baudrate, true);\n        view.setUint8(4, kStopbitsIndexMapping.indexOf(this.serialOptions_.stopbits));\n        view.setUint8(5, kParityIndexMapping.indexOf(this.serialOptions_.parity));\n        view.setUint8(6, this.serialOptions_.databits);\n        return buffer;\n    }\n    /**\n     * Check whether the passed device is a serial device with the proper\n     * interface classes\n     * @param {object} device the device acquired from the WebUSB API\n     * @return {boolean} the boolean indicating whether the device is structured\n     * as a serial device\n     */\n    static isSerialDevice(device) {\n        if (!(device.configurations instanceof Array)) {\n            return false;\n        }\n        let hasInterfaceClassTen = false;\n        let hasInterfaceClassTwo = false;\n        device.configurations.forEach((config) => {\n            if (config.interfaces instanceof Array) {\n                config.interfaces.forEach((thisInterface) => {\n                    if (thisInterface.alternates instanceof Array) {\n                        thisInterface.alternates.forEach((alternate) => {\n                            if (alternate.interfaceClass === 10) {\n                                hasInterfaceClassTen = true;\n                            }\n                            if (alternate.interfaceClass === 2) {\n                                hasInterfaceClassTwo = true;\n                            }\n                        });\n                    }\n                });\n            }\n        });\n        return hasInterfaceClassTen && hasInterfaceClassTwo;\n    }\n    /**\n     * Finds the interface used for controlling the serial device\n     * @param {Object} device the object for a device from the WebUSB API\n     * @return {object} The interface Object created from the WebUSB API that is\n     * expected to handle the control of the Serial Device\n     */\n    getControlInterface(device) {\n        return this.getInterfaceWithClass(device, 2);\n    }\n    /**\n     * Finds the interface used for transfering data over the serial device\n     * @param {Object} device the object for a device from the WebUSB API\n     * @return {object} The interface Object created from the WebUSB API that is\n     * expected to handle the transfer of data.\n     */\n    getTransferInterface(device) {\n        return this.getInterfaceWithClass(device, 10);\n    }\n    /**\n     * Utility used to get any interface on the device with a given class number\n     * @param {Object} device the object for a device from the WebUSB API\n     * @param {Object} classNumber The class number you want to find\n     * @return {object} The interface Object created from the WebUSB API that is\n     * has the specified classNumber\n     */\n    getInterfaceWithClass(device, classNumber) {\n        let interfaceWithClass;\n        device.configuration.interfaces.forEach((deviceInterface) => {\n            deviceInterface.alternates.forEach((alternate) => {\n                if (alternate.interfaceClass === classNumber) {\n                    interfaceWithClass = deviceInterface;\n                }\n            });\n        });\n        return interfaceWithClass;\n    }\n    /**\n     * Utility function to get an endpoint from the Tranfer Interface that\n     * has the given direction\n     * @param {String} direction A string either \"In\" or \"Out\" specifying the\n     * direction requested\n     * @return {object} The Endpoint Object created from the WebUSB API that is\n     * has the specified direction\n     */\n    getDirectionEndpoint(direction) {\n        let correctEndpoint;\n        this.transferInterface_.alternates.forEach((alternate) => {\n            alternate.endpoints.forEach((endpoint) => {\n                if (endpoint.direction == direction) {\n                    correctEndpoint = endpoint;\n                }\n            });\n        });\n        return correctEndpoint;\n    }\n}\nexports.SerialPort = SerialPort;\n/** implementation of the global navigator.serial object */\nclass Serial {\n    /** requests permission to access a new port */\n    async requestPort() {\n        const filters = [\n            { classCode: 10 },\n        ];\n        const device = await navigator.usb.requestDevice({ 'filters': filters });\n        const port = new SerialPort(device);\n        return port;\n    }\n    /** gets the list of available ports */\n    async getPorts() {\n        const devices = await navigator.usb.getDevices();\n        const serialDevices = [];\n        devices.forEach((device) => {\n            if (SerialPort.isSerialDevice(device)) {\n                serialDevices.push(new SerialPort(device));\n            }\n        });\n        return serialDevices;\n    }\n}\n/* an object to be used for starting the serial workflow */\nexports.serial = new Serial();\n//# sourceMappingURL=serial.js.map","import React from 'react'\nimport { serial } from 'web-serial-polyfill'\n\nfunction AndroidSerialLoader() {\n  ;(navigator as any).serial = serial\n  return <></>\n}\n\nexport default AndroidSerialLoader\n"],"sourceRoot":""}